class StackNode:
    def __init__(self, data):
        self.data = data
        self.next = None


class Stack:
    def __init__(self):
        self.top = None

    def push(self, data):
        node = StackNode(data)
        node.next = self.top
        self.top = node

    def pop(self):
        if self.is_empty():
            return None
        data = self.top.data
        self.top = self.top.next
        return data

    def peek(self):
        if self.is_empty():
            return None
        return self.top.data

    def is_empty(self):
        return self.top is None

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def precedence(op):
    if op == '+' or op == '-':
        return 1
    if op == '*' or op == '/':
        return 2
    return 0


def is_operator(c):
    return c in ['+', '-', '*', '/']


def infix_to_postfix(expression):
    stack = Stack()
    output = ""

    i = 0
    while i < len(expression):

        if expression[i].isdigit():
            num = ""
            while i < len(expression) and expression[i].isdigit():
                num += expression[i]
                i += 1
            output += num + " "
            continue

        elif expression[i] == '(':
            stack.push('(')

        elif expression[i] == ')':
            while not stack.is_empty() and stack.peek() != '(':
                output += stack.pop() + " "
            stack.pop() 

        elif is_operator(expression[i]):
            while (not stack.is_empty() and
                   precedence(stack.peek()) >= precedence(expression[i])):
                output += stack.pop() + " "
            stack.push(expression[i])

        i += 1

    while not stack.is_empty():
        output += stack.pop() + " "

    return output.strip()


def build_expression_tree(postfix):
    stack = Stack()
    tokens = postfix.split()

    for token in tokens:

        if not is_operator(token):
            node = TreeNode(token)
            stack.push(node)

        else:
            node = TreeNode(token)
            right = stack.pop()
            left = stack.pop()
            node.right = right
            node.left = left
            stack.push(node)

    return stack.pop()


def evaluate(root):

    if root is None:
        return 0

    if not is_operator(root.value):
        return int(root.value)

    left_val = evaluate(root.left)
    right_val = evaluate(root.right)

    if root.value == '+':
        return left_val + right_val
    if root.value == '-':
        return left_val - right_val
    if root.value == '*':
        return left_val * right_val
    if root.value == '/':
        return left_val / right_val

def main():
    expression = input("Enter Infix Expression: ")

    postfix = infix_to_postfix(expression)
    print("Postfix:", postfix)

    tree_root = build_expression_tree(postfix)
    result = evaluate(tree_root)

    print("Result:", result)


if __name__ == "__main__":
    main()
